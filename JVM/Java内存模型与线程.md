## Java内存模型与线程



#### 多线程并发问题

多线程并发并不只有计算就能完成，还涉及到了内存的交互，而内存交互又带来了新的问题即**缓存一致性**。当多个任务涉及到同一块主内存区域，且各自的缓存数据不一致，则引发了缓存不一致的问题。

![image-20200713105841247](E:\homework\Markdown\JVM\img\image-20200713105841247.png)

#### Java内存模型

为解决缓存一致性问题，Java内存模型（JMM）规定了：

- 所有的变量都存储在主内存中
- 每条线程还有自己的工作内存，工作内存中保存了被该线程使用的变量的主内存副本。
- 线程的操作均在工作内存中进行，而不能直接读写主内存中的数据。
- 不同线程间也无法直接访问对方线程的工作内存的变量，线程间的值传递需要通过主内存完成。

#### volatile关键字

当一个变量被定义为`vloatile`之后，它将具备两条特性：

1. 可见性

   当一条线程修改了该变量的值，新值对其他线程可以立即得知。注意，只有可见性不能保证线程安全，因为volatile不能保证操作的原子性，即使读到的数据是正确的，但也有可能有多个线程在同时修改，导致修改覆盖的现象。

2. 有序性：

   表示禁止指令重排序优化。使用非volatile的普通变量仅保证只要得到正确结果就行，而不能保证操作的顺序和程序代码中的执行顺序一样。

#### 内存模型并发的三特性

1. 原子性：

   保证原子性变量操作包括read、load、assign、use、store和write。

2. 可见性

3. 有序性



## 线程

#### 线程的实现

实现线程主要有三种方式 ：使用内核线程实现（ 1: 1 实现），使用用户线程实现（ l:N 实现），使用用户线程加轻量级进程混合实现 （N:M实现）。

1. #### 内核线程实现

   程序一般不会直接使用内核线程（KLT，kernel-Level Thread），而是使用内核线程的一种高级接口——轻量级进程（LWP，Light Weight Process），每一个轻量级进程都有一个内核级线程支持，故为1:1线程模型。

   ![image-20200713144445566](E:\homework\Markdown\JVM\img\image-20200713144445566.png)

2. #### 用户线程实现

   用户线程指完全建立在用户控件的线程库上，系统内核不能感知到用户线程的存在和实现。用户线程的建立、同步、销毁和调度不需要内核的帮助，完全由用户程序自己处理。

   这样做快速且低消耗，但是由于没有内核的支援，所有的线程操作都需要由用户程序自己去处理，遇到一些复杂的问题会异常难去处理。Java、Ruby等语言都层使用过用户线程，最终放弃了使用它，但最近以高并发为卖点的编程语言又普遍支持用户线程，如Golang、Erlang。

   ![image-20200713145031484](E:\homework\Markdown\JVM\img\image-20200713145031484.png)

3. #### 混合实现

   将内核线程与用户线程一起使用的实现方式

   ![image-20200713145121605](E:\homework\Markdown\JVM\img\image-20200713145121605.png)