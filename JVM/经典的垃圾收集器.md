## 经典垃圾收集器

![image-20200711193259214](E:\homework\Markdown\JVM\img\image-20200711193259214.png)

1. ### Serial收集器

   最基础、历史最悠久的收集器。该收集器为单线程且在进行垃圾收集时，必须暂停其他所有工作线程、直至收集结束。

   但它依然是HotSpot虚拟机运行在**客户端**模式下的默认新生代收集器。优点为简单而高效，是所有额外内存消耗最小的。在收集几十兆甚至一两百兆的新生代，垃圾收集的停顿时间完全可以控制在十几、几十毫秒内，这对于用户是完全可以接受的，所以Serial 收集器对于运行在客户端模式下的虚拟机来说是一个很好的选择。

   ![image-20200711194855321](E:\homework\Markdown\JVM\img\image-20200711194855321.png)

2. ### ParNew收集器

   Par New 收集器实质上是 Serial 收集器的多线程并行版本，除了同时使用多条线程 进行垃圾收集之外，其余的行为包括 Serial 收集器可用的所有控制参数（例如：去X: SurvivorRatio、 －XX:PretenureSizeThreshold、去X:HandlePromotionFailure 等）、收集算法、 Stop The World、对象分配规则、回收策略等都与 Serial 收集器完全一致，在实现上这两种 收集器也共用了相当多的代码。 

   它是Server端的收集器，在JDK7之前首选的新生代收集器，原因是除了Serial收集器以外，目前只有它能与CMS收集器配合工作。

   ![image-20200711194909708](E:\homework\Markdown\JVM\经典的垃圾收集器.assets\image-20200711194909708.png)

3. ### Parallel Scavenge 收集器 

   Parallel Scavenge收集器也是一款新生代收集器，它同样是基于标记 一 复制算法实现的收集器。

   该收集器侧重于达到一个可控制的吞吐量，Parallel Scavenge 收集器也经常被称作“吞吐量优先收集器” 。 

   停顿的时间是通过控制吞吐量和新生代空间来实现，空间越小，清理的越快，但清理的次数也越频繁，吞吐量也降下来了。

   停顿时间越短就越适合需要与用户交互或需要保证服务响 应质量的程序，良好的响应速度能提升用户体验；而高吞吐量则可以最高效率地利用处理 器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务。 

   ![image-20200711195855225](E:\homework\Markdown\JVM\经典的垃圾收集器.assets\image-20200711195855225.png)

   Parallel Scavenge 收集器还有一个参数 －XX:+UseAdaptiveSizePolicy 值得我们关注。 这是一个开关参数，用来打开垃圾收集的自适应的调节策略（ GC Ergonomics），当这个参数被激活之后，就不需要人工指定新生代的 大小（－Xmn）、 Eden 与 Survivor 区的比例 （XX:SurvivorRatio）、 晋升老年代对象大小（－XX:PretenureS izeThreshold）等细节参数了， 虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。 

4. ### Serial Old收集器

   Serial Old是Serial收集器的老年代版本，单线程收集器，使用标记-整理法，也是给Client场景下使用。如果在Server场景下，主要有两大用途：

   - 一种是在 JDK 5 以及之前的版本中与 Parallel Scavenge 收集 器搭配使用。
   - 另外一种就是作为 CMS 收集器发生失败时的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。 

   ![image-20200711201559394](E:\homework\Markdown\JVM\img\image-20200711201559394.png)

5. ### Parallel Old 收集器

   Parallel Old 是 Parallel Scavenge 收集器的老年代版本， 支持多线程并发收集，基于 标记 － 整理算法实现。 

   在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器这个组合。

   ![image-20200711201835772](E:\homework\Markdown\JVM\img\image-20200711201835772.png)

6. ### CMS收集器

   CMS ( Concurrent Mark Sweep） 收集器是一种以获取最短回收停顿时间为目标的收集器。基于标记-清除算法实现。过程共分为4步：

   1. 初始标记：简单标记一下GC Roots能直接关联到的对象，速度很快，需要暂停用户线程。
   2. 并发标记：从GC Roots直接关联的对象开始遍历整个对象图的过程，这个耗时长，不需要暂停用户线程。
   3. 重新标记：修正并发标记期间，因用户程序继续运作导致标记产生变动的那一部分对象的标记记录，需要暂停。
   4. 并发清除：清除标记的对象，不需要暂停。

   ![image-20200711202719734](E:\homework\Markdown\JVM\img\image-20200711202719734.png)

   缺点：

   1. 消耗处理器运算资源，对于处理器核心数量较少或性能不强的情况会导致程序的执行速度忽然大幅降低。

   2. 无法处理浮动垃圾，可能出现并发失败（Concurrent Mode Failure，这时虚拟机启动后备预案：冻结用户线程，临时启动Serial Old 收集器来重新进行老年代的垃圾收集）。

      浮动垃圾是在并发标记和并发清理阶段，因为用户线程继续运行而产生的垃圾，这部分只能等到下一次GC时才能进行回收。

      因此需要预留一些空间给用户线程使用，如果预留的空间不够存放浮动垃圾，则Concurrent Mode Failure

   3. 标记-清除算法导致的空间碎片，无法找到连续的空间来分配较大的对象，不得不触发一次Full GC。
   
7. ### Garbage First收集器

   该收集器也称为G1，是一款面向服务端应用的垃圾收集器，其收集的范围是整个新生代或老年代。

   G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相对的独立区域（Region）

   Region 中还有一类特殊的 Humongous 区域，专门用来存储大对象。 GI 认为只要大小超过了一个Region容量一半的对象即可判定为大对象。 

   G1之所以能建立可预测停顿时间模型，是因为它跟踪各个Region的回收价值，并维护一个优先级列表，根据用户设定允许的收集停顿时间，优先处理回收价值最大的那些Region，保证在优先的时间内获取尽可能高的收集效率。

   G1收集器使用了记忆集来记录跨Region引用对象，已达到在做可达性分析时避免全堆作为GC Roots扫描。G1在记忆集上除了记录“我指向谁”，还记录了“谁指向我”。

   如果不计算维护记忆集的操作，G1收集器的运作大致可划分为：

   1. **初始标记**：简单标记下GC Roots能直接关联到的对象，并修改TAMS指针，为并发标记中正确的为出现的新对象分配Region。需暂停，但耗时短。
   2. **并发标记**：进行可达性分析，递归扫描整个堆的对象图。耗时长，但可与用户程序并发执行。
   3. **最终标记**：为了修正正在并发标记期间用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的Remembered Set Logs里面，最终标记阶段要把Remembered Set Logs的数据合并到记忆集中。这部分需要暂停用户程序，可并行执行。
   4. **筛选回收**：对各个Region中的回收价值和成本进行排序，根据用户期望的GC停顿时间来制定回收计划。该回收涉及到存活对象的移动。

   

   ## 内存分配与回收策略

   ### Minor GC和Full GC

   - Minor GC：回收新生代，因为新生代对象存活时间短，因此Minor会频繁执行，执行速度较快。
   - Full GC：回收老年代和新生代，老年代存活时间长，因此Full GC较少执行，且执行速度较慢。

   

   ### 内存分配策略 

   1. 对象优先在 Eden 分配 
   大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。
   2. 大对象直接进入老年代 
   大对象是指需要连续内存空间的对象，典型的大对象是那种很长的字符串以及数组。
   经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。
   -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。
   3. 长期存活的对象进入老年代 
   为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁， 增加到一定年龄则移动到老年代中。
   -XX:MaxTenuringThreshold 用来定义年龄的阈值。
   4. 动态对象年龄判定 
   虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄 所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。
   5. 空间分配担保 
   在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的 话，那么 Minor GC 可以确认是安全的。
   如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。 

   

   ### Full GC 的触发条件 

   对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以 下条件：

   1. 调用 System.gc() 
      只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存
   2. 老年代空间不足 
      老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。
      为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数 调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对 象进入老年代的年龄，让对象在新生代多存活一段时间。
   3. 空间分配担保失败 
      使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面 的第 5 小节。
   4. JDK 1.7 及以前的永久代空间不足 
      在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静 态变量等数据。
      当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也 会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。 为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。
   5. Concurrent Mode Failure 执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时 性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。 

   
