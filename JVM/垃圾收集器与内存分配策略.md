## 垃圾收集算法与内存分配策略

1. ### 关于垃圾收集(Garbage Collection,GC)

   垃圾收集需要完成的三件事情： 

   -  哪些内存需要回收？ 
   - 什么时候回收？
   - 如何回收？ 

2. ### 如何判断对象的存活状态

   1. 引用计数算法：在对象中添加一个引用计数器，没当一个地方引用它时，计数器加一，引用失效时，计数器减一。任何时刻计数器为零的对象就是不可能再次被使用的。该算法实现简单，效率也很高，但是Java主流虚拟机没有选用引用计数法来管理内存，主要原因是，这个看似简单的算法有很多例外情况要 考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数就很难解决对象之间相互循环引用的问题。 例子如下：

      ```
      对象 objA 和 objB 都有字段 instance，赋值令 objA.instanc巳＝ objB 及 objB.instance = objA，除此之外，这两个对象再无 任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致 它们的引用计数都不为零，引用计数算法也就无法回收它们。
      ```

   2. 可达性分析算法：当前主流商业程序语言的内存管理子系统都是使用可达性(Reachability Analysis)分析来判断对象是否存活。

      该算法思路为通过一系列称为`"GC Roots"`的根对象作为起始节点，根据引用关系向下搜索，搜索过程所走过的路径称为"引用链（Reference Chain）"，若某个对象到GCRoots不存在任何引用链相连，即对象到GCRoots不可达，则证明此对象是不可能再被使用的。

      ![image-20200711162925365](E:\homework\Markdown\JVM\img\image-20200711162925365.png)

      在Java中，固定作为GC Roots的对象包括：

      - 在虚拟机栈（栈帧中的本地变量表） 中引用的对象， 譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
      -  在方法区中类静态属性引用的对象，譬如 Java 类的引用类型静态变量。
      - 在方法区中常量引用的对象， 譬如字符串常量池（String Table）里的引用。 
      - 在本地方法栈中JNI （即通常所说的 Native 方法）引用的对象。
      - Java 虚拟机内部的引用，如基本数据类型对应的 Class 对象， 一些常驻的异常对象 （比如 Nul!PointExcepiton、 OutOfMemoryError）等，还有系统类加载器。
      - 所有被同步锁（synchronized 关键字）持有的对象。 
      - 反映 Java 虚拟机内部情况的 JMXBean、 JVMTI 中注册的回调、本地代码缓存等。 

   3. 引用分类：JDK1.2之后，Java对引用的概念进行了扩充

      - **强引用**是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即 类似“ Object obj = new Object（）”这种引用关系。 无论任何情况下，只要强引用关 系还存在，垃圾收集器就永远不会回收掉被引用的对象。 
      - **软引用**是用来描述一些还有用，但非必须的对象。 只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。 在 JDK 1.2 版之后提供了 SoftReference 类来实现软引用。
      -  **弱引用**也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。 当垃圾收集器开始工作，无论 当前内存是否足够，都会回收掉只被弱引用关联的对象。 在 JDK 1.2 版之后提供了 WeakReference 类来实现弱引用。 
      - **虚引用**也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。 一个对象 是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得 一个对象实例。 为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收 集器回收时收到一个系统通知。 在 JDK 1.2 版之后提供了 PhantomReference 类来实 现虚引用。

   4. #### 回收方法区

      在Java堆中，尤其是新生代中，对常规应用进行一次垃圾回收通常可以回收70%-90%的内存空间。相比之下方法区垃圾回收性价比则较低，因为其回收的条件较于苛刻，方法区回收成果往往远低于此。

      1. 对于方法区中的常量，判断和堆类似，看有无对象引用该常量。
      2. 而对于类是否废弃则较为苛刻：
         - 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例。
         - 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、 JSP 的重加载等，否则通常是很难达成的。
         - 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

      **在大量使用反射、动态代理、 CGLib 等字节码框架，动态生成 JSP 以及 OSGi 这类频 繁自定义类加载器的场景中，通常都需要 Java 虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。**

3. ### 垃圾回收算法

   1. 分代收集的理论：新生代（Young Generation）和老年代(Old Generation)。在新生代中每次垃圾回收都有大批对象死去，每次回收存活的少量对象会逐渐晋升到老年代中存放。
   2. 跨代引用假说：对象不是孤立的，对象之间可能存在跨代引用，但跨代引用对于同代引用来说仅占极少数。

   关于垃圾收集的一些名词：

   部分收集（ Partial GC）：指目标不是完整收集整个 Java 堆的垃圾收集，其中又 分为 ： 

   - 新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。
   - 老年代收集（ Major GC/Old GC）：指目标只是老年代的垃圾收集。 目前只有 CMS 收集器会有单独收集老年代的行为 。 另外请注意“ Major GC ”这个说 法现在有点混淆，在不同资料上常有不同所才旨，读者需按上下文区分到底是 指**老年代的收集还是整堆收集**。
   - 混合收集（ Mixed GC ）：指目标是收集整个新生代以及部分老年代的垃圾收集。 目前只有 Gl 收集器会有这种行为 。

   整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾收集。

   3. #### 标记-清除算法

      最基础的收集算法，根据标记来判断对象是否回收，或根据标记来判断对象是否存活。

      该算法的缺点为：

      1. 执行效率不稳定，当遇到需要回收大量对象时，需要执行大量标记和清除操作者，执行效率随标记对象的数量增长而降低。
      2. 标记、清除之后可能产生大量不连续的内存碎片，空间碎片太多可能导致之后的程序在运行过程中需要分配较大对象时，无法找到足够的连续的空间而不得不触发另一次垃圾收集动作。

      ![image-20200711172607722](E:\homework\Markdown\JVM\img\image-20200711172607722.png)

   4. #### 标记-复制算法

      按照容量将内存分为大小相等的两块，每次只使用其中的一块。当一块用完了就将存活的对象复制到另一块，再将已使用的区域清理掉。

      缺点：标记-复制法在对象存活率较高的时候，效率将降低。将可用内存缩小为了原来的一半，空间浪费过多

      ![](E:\homework\Markdown\JVM\垃圾收集器与内存分配策略.assets\image-20200711174256348-1594460829970.png)

      额外了解：在 1989 年， Andrew Appel 针对具备“朝生夕灭”特点的对象，提出了一种更优化的半区复制分代策略，现在称为“ **Appel 式回收**” 。  Appel 式回收的具体做法是把新生代 分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次分配内存只使用 Eden 和其中 一块 Survivor。 发生垃圾搜集时，将 Eden 和 Survivor 中仍然存活的对象一次性复制到另外 一块 Survivor 空间上，然后直接清理掉 Eden 和已用过的那块 Survivor 空间。 HotSpot 虚拟 机默认 Eden 和 Survivor 的大小比例是 8 : 1 ，也即每次新生代中可用内存空间为整个新生代 容量的 90% (Eden 的 80% 加上一个 Survivor 的 10%），只有一个 Survivor 空间，即 10% 的 新生代是会被“浪费”的。 当然， 98% 的对象可被回收仅仅是“普通场景”下测得的数据， 任何人都没有办法百分百保证每次回收都只有不多于 10% 的对象存活，因此 Appel 式回收 还有一个充当罕见情况的“逃生门”的安全设计，当 Survivor 空间不足以容纳一次 Minor GC 之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保 (Handle Promotion ） 。 

   5. #### 标记整理法

       “标记－整理”（ Mark-Compact）算法，其中的标记过程仍然与“标记 － 清除”算法一样，但后 续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动， 然后直接清理掉边界以外的内存。这是一种移动式回收算法。

      缺点：如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域， 移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作 必须全程暂停用户应用程序才能进行。

      ![image-20200711191133322](E:\homework\Markdown\JVM\img\image-20200711191133322.png)

